<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Trascrizione in Tempo Reale</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 20px;
      color: #333;
    }

    /* ========== LANDING PAGE ========== */
    #landingPage {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      text-align: center;
      gap: 40px;
    }

    #landingPage h1 {
      font-size: 48px;
      color: white;
      text-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    #landingPage p {
      font-size: 20px;
      color: rgba(255, 255, 255, 0.9);
      max-width: 600px;
    }

    #connectBtn {
      padding: 30px 60px;
      font-size: 28px;
      font-weight: 700;
      background: white;
      color: #667eea;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #connectBtn:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
      background: #f0f0f0;
    }

    #connectBtn:active {
      transform: translateY(-2px);
    }

    /* ========== MAIN APP (HIDDEN INITIALLY) ========== */
    .container {
      max-width: 600px;
      width: 100%;
      margin: 0 auto;
      display: none; /* Hidden until user clicks connect */
      flex-direction: column;
      gap: 20px;
      flex: 1;
    }

    .container.active {
      display: flex;
    }

    .header {
      text-align: center;
      color: white;
      padding: 20px 0;
    }

    .header h1 {
      font-size: 28px;
      margin-bottom: 8px;
    }

    .header p {
      font-size: 14px;
      opacity: 0.9;
    }

    .controls {
      background: white;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .mode-selection {
      margin-bottom: 20px;
    }

    .mode-selection h3 {
      font-size: 16px;
      color: #374151;
      margin-bottom: 12px;
      text-align: center;
    }

    .mode-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 20px;
    }

    .mode-btn {
      padding: 16px 12px;
      background: #f3f4f6;
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      text-align: center;
    }

    .mode-btn span {
      font-size: 24px;
    }

    .mode-btn strong {
      display: block;
      font-size: 14px;
      color: #1f2937;
      margin-bottom: 4px;
    }

    .mode-btn small {
      font-size: 11px;
      color: #6b7280;
      line-height: 1.3;
    }

    .mode-btn:hover {
      border-color: #667eea;
      background: #f9fafb;
    }

    .mode-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: #667eea;
      color: white;
    }

    .mode-btn.active strong,
    .mode-btn.active small {
      color: white;
    }

    .button-group {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
    }

    button {
      flex: 1;
      padding: 16px 24px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    #startBtn {
      background: #10b981;
      color: white;
    }

    #startBtn:hover {
      background: #059669;
    }

    #startBtn:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }

    #stopBtn {
      background: #ef4444;
      color: white;
    }

    #stopBtn:hover {
      background: #dc2626;
    }

    #stopBtn:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }

    .status {
      padding: 12px 16px;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
      font-size: 14px;
    }

    .status.idle {
      background: #f3f4f6;
      color: #6b7280;
    }

    .status.connecting {
      background: #fef3c7;
      color: #92400e;
    }

    .status.recording {
      background: #dcfce7;
      color: #166534;
      animation: pulse 2s infinite;
    }

    .status.error {
      background: #fee2e2;
      color: #991b1b;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }

    .transcript-container {
      background: white;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 300px;
    }

    .transcript-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid #f3f4f6;
    }

    .transcript-header h2 {
      font-size: 18px;
      color: #1f2937;
    }

    #clearBtn {
      padding: 8px 16px;
      font-size: 14px;
      background: #f3f4f6;
      color: #6b7280;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    #clearBtn:hover {
      background: #e5e7eb;
    }

    .transcript-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      background: #f9fafb;
      border-radius: 8px;
      font-size: 16px;
      line-height: 1.6;
      color: #374151;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .transcript-content:empty::before {
      content: "La trascrizione apparir√† qui...";
      color: #9ca3af;
      font-style: italic;
    }

    .interim {
      color: #9ca3af;
      font-style: italic;
    }

    @media (max-width: 480px) {
      body {
        padding: 12px;
      }

      #landingPage h1 {
        font-size: 36px;
      }

      #landingPage p {
        font-size: 16px;
      }

      #connectBtn {
        padding: 20px 40px;
        font-size: 22px;
      }

      .header h1 {
        font-size: 24px;
      }

      .controls, .transcript-container {
        padding: 16px;
      }

      .mode-buttons {
        grid-template-columns: 1fr;
      }

      button {
        padding: 14px 20px;
        font-size: 15px;
      }
    }
  </style>
</head>
<body>
  <!-- ========== LANDING PAGE ========== -->
  <div id="landingPage">
    <div>
      <h1>üé§ Benvenuto</h1>
      <p>Clicca il pulsante per iniziare a parlare con l'avatar</p>
    </div>
    <button id="connectBtn">
      Parla con l'Avatar
    </button>
  </div>

  <!-- ========== MAIN APP (HIDDEN) ========== -->
  <div class="container" id="mainApp">
    <div class="header">
      <h1>üé§ Trascrizione in Tempo Reale</h1>
      <p>Powered by Deepgram</p>
    </div>

    <div class="controls">
      <div class="mode-selection">
        <h3>Seleziona Modalit√†:</h3>
        <div class="mode-buttons">
          <button id="realtimeMode" class="mode-btn active">
            <span>üî¥</span>
            <div>
              <strong>Tempo Reale</strong>
              <small>Trascrizione istantanea</small>
            </div>
          </button>
          <button id="recordMode" class="mode-btn">
            <span>‚è∫Ô∏è</span>
            <div>
              <strong>Registra & Trascrivi</strong>
              <small>Prima registra, poi trascrivi</small>
            </div>
          </button>
        </div>
      </div>

      <div class="button-group">
        <button id="startBtn">
          <span>‚ñ∂</span>
          <span id="startBtnText">Avvia Tempo Reale</span>
        </button>
        <button id="stopBtn" disabled>
          <span>‚èπ</span>
          <span>Ferma</span>
        </button>
      </div>
      <div id="status" class="status idle">Pronto per iniziare</div>
    </div>

    <div class="transcript-container">
      <div class="transcript-header">
        <h2>Trascrizione</h2>
        <button id="clearBtn">Cancella</button>
      </div>
      <div id="transcript" class="transcript-content"></div>
    </div>
  </div>

  <script>
    const DEEPGRAM_API_KEY = '87ce09f5219486e115182b4252e98370723dda2b';
    const DEEPGRAM_URL = 'wss://api.deepgram.com/v1/listen?encoding=linear16&sample_rate=16000&channels=1&language=it&interim_results=true';
    
    const RELAY_SERVER_URL = 'wss://agent-app-talk.onrender.com';

    let deepgramSocket;
    let relaySocket;
    let audioStream;
    let audioContext;
    let processor;
    let mediaRecorder;
    let audioChunks = [];
    let currentMode = 'realtime';

    const landingPage = document.getElementById('landingPage');
    const mainApp = document.getElementById('mainApp');
    const connectBtn = document.getElementById('connectBtn');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusDiv = document.getElementById('status');
    const transcriptDiv = document.getElementById('transcript');
    const clearBtn = document.getElementById('clearBtn');
    const realtimeMode = document.getElementById('realtimeMode');
    const recordMode = document.getElementById('recordMode');
    const startBtnText = document.getElementById('startBtnText');

    let finalTranscript = '';
    let interimTranscript = '';

    // ========== "PARLA CON L'AVATAR" BUTTON CLICK ========== 
    connectBtn.addEventListener('click', () => {
      // Hide landing page
      landingPage.style.display = 'none';
      
      // Show main app
      mainApp.classList.add('active');
      
      // Connect to relay server
      connectToRelay();
    });

    // Connect to relay server
    function connectToRelay() {
      try {
        relaySocket = new WebSocket(RELAY_SERVER_URL);
        
        relaySocket.onopen = () => {
          console.log('Connected to relay server');
          
          // Identify as web client - THIS KICKS OUT PREVIOUS USER
          relaySocket.send(JSON.stringify({
            type: 'identify',
            client: 'web'
          }));
        };

        relaySocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            
            // Handle being kicked out
            if (data.type === 'kicked_out') {
              stopRecording();
              
              // Show error
              updateStatus(data.message || 'Sei stato disconnesso', 'error');
              
              // Disable everything
              startBtn.disabled = true;
              realtimeMode.disabled = true;
              recordMode.disabled = true;
              
              // Close relay
              if (relaySocket) {
                relaySocket.close();
                relaySocket = null;
              }
              
              // Show alert
              alert('‚ö†Ô∏è ' + (data.message || 'Un altro utente si √® connesso'));
              
              // Go back to landing page
              setTimeout(() => {
                mainApp.classList.remove('active');
                landingPage.style.display = 'flex';
                
                // Re-enable buttons for next time
                startBtn.disabled = false;
                realtimeMode.disabled = false;
                recordMode.disabled = false;
              }, 2000);
              
              return;
            }
            
          } catch (error) {
            console.error('Error processing relay message:', error);
          }
        };

        relaySocket.onclose = () => {
          console.log('Disconnected from relay server');
          relaySocket = null;
        };

        relaySocket.onerror = (error) => {
          console.error('Relay server error:', error);
        };
      } catch (error) {
        console.error('Failed to connect to relay:', error);
      }
    }

    function sendToUnity(text, isFinal) {
      if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
        const data = {
          text: text,
          isFinal: isFinal,
          timestamp: new Date().toISOString()
        };
        relaySocket.send(JSON.stringify(data));
        console.log('Sent to Unity:', data);
      } else {
        console.log('Relay not connected, cannot send:', text);
      }
    }

    realtimeMode.addEventListener('click', () => {
      if (audioStream) return;
      currentMode = 'realtime';
      realtimeMode.classList.add('active');
      recordMode.classList.remove('active');
      startBtnText.textContent = 'Avvia Tempo Reale';
      updateStatus('Modalit√† Tempo Reale - Pronto', 'idle');
    });

    recordMode.addEventListener('click', () => {
      if (audioStream) return;
      currentMode = 'record';
      recordMode.classList.add('active');
      realtimeMode.classList.remove('active');
      startBtnText.textContent = 'Avvia Registrazione';
      updateStatus('Modalit√† Registra & Trascrivi - Pronto', 'idle');
    });

    function updateStatus(message, type = 'idle') {
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
    }

    function updateTranscript() {
      transcriptDiv.innerHTML = finalTranscript + 
        (interimTranscript ? `<span class="interim">${interimTranscript}</span>` : '');
      transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
    }

    async function startRecording() {
      if (currentMode === 'realtime') {
        await startRealtimeMode();
      } else {
        await startRecordMode();
      }
    }

    async function startRealtimeMode() {
      try {
        updateStatus('Richiesta accesso al microfono...', 'connecting');
        
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('Il tuo browser non supporta l\'accesso al microfono');
        }

        audioStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          } 
        });

        updateStatus('Connessione a Deepgram...', 'connecting');

        deepgramSocket = new WebSocket(DEEPGRAM_URL, ['token', DEEPGRAM_API_KEY]);

        deepgramSocket.onopen = () => {
          updateStatus('üî¥ Registrazione Tempo Reale...', 'recording');
          startBtn.disabled = true;
          stopBtn.disabled = false;
          setupAudioProcessing();
        };

        deepgramSocket.onmessage = (message) => {
          const data = JSON.parse(message.data);
          
          if (data.type === 'Results') {
            const transcript = data.channel.alternatives[0].transcript;
            
            if (transcript && transcript.trim() !== '') {
              if (data.is_final) {
                finalTranscript += transcript + ' ';
                interimTranscript = '';
                sendToUnity(transcript, true);
              } else {
                interimTranscript = transcript;
                sendToUnity(transcript, false);
              }
              updateTranscript();
            }
          }
        };

        deepgramSocket.onerror = (error) => {
          console.error('WebSocket error:', error);
          updateStatus('Errore di connessione', 'error');
          stopRecording();
        };

        deepgramSocket.onclose = () => {
          updateStatus('Connessione chiusa', 'idle');
        };

      } catch (error) {
        handleError(error);
      }
    }

    async function startRecordMode() {
      try {
        updateStatus('Richiesta accesso al microfono...', 'connecting');
        
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('Il tuo browser non supporta l\'accesso al microfono');
        }

        audioStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          } 
        });

        updateStatus('üî¥ Registrazione in corso...', 'recording');
        startBtn.disabled = true;
        stopBtn.disabled = false;

        audioChunks = [];
        mediaRecorder = new MediaRecorder(audioStream);

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          updateStatus('Elaborazione audio...', 'connecting');
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          await transcribeAudio(audioBlob);
        };

        mediaRecorder.start();

      } catch (error) {
        handleError(error);
      }
    }

    async function transcribeAudio(audioBlob) {
      try {
        updateStatus('Invio a Deepgram per trascrizione...', 'connecting');

        const response = await fetch('https://api.deepgram.com/v1/listen?language=it&punctuate=true&utterances=true', {
          method: 'POST',
          headers: {
            'Authorization': `Token ${DEEPGRAM_API_KEY}`,
            'Content-Type': 'audio/webm'
          },
          body: audioBlob
        });

        if (!response.ok) {
          throw new Error(`Errore Deepgram: ${response.status}`);
        }

        const data = await response.json();
        
        if (data.results && data.results.channels && data.results.channels[0].alternatives) {
          const transcript = data.results.channels[0].alternatives[0].transcript;
          
          if (transcript && transcript.trim() !== '') {
            finalTranscript += transcript + ' ';
            sendToUnity(transcript, true);
            updateTranscript();
            updateStatus('‚úÖ Trascrizione completata!', 'idle');
          } else {
            updateStatus('‚ö†Ô∏è Nessun audio rilevato', 'error');
          }
        } else {
          updateStatus('‚ö†Ô∏è Nessuna trascrizione ricevuta', 'error');
        }

        startBtn.disabled = false;
        stopBtn.disabled = true;

      } catch (error) {
        console.error('Transcription error:', error);
        updateStatus(`Errore trascrizione: ${error.message}`, 'error');
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    function handleError(error) {
      console.error('Error:', error);
      
      let errorMessage = 'Errore sconosciuto';
      
      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
        errorMessage = 'Permesso microfono negato. Abilita il microfono nelle impostazioni del browser.';
      } else if (error.name === 'NotFoundError') {
        errorMessage = 'Nessun microfono trovato';
      } else if (error.name === 'NotReadableError') {
        errorMessage = 'Microfono gi√† in uso da un\'altra applicazione';
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      updateStatus(errorMessage, 'error');
      stopRecording();
    }

    function setupAudioProcessing() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
        const source = audioContext.createMediaStreamSource(audioStream);
        
        processor = audioContext.createScriptProcessor(4096, 1, 1);
        
        processor.onaudioprocess = (e) => {
          if (deepgramSocket && deepgramSocket.readyState === WebSocket.OPEN) {
            const inputData = e.inputBuffer.getChannelData(0);
            
            const int16Data = new Int16Array(inputData.length);
            for (let i = 0; i < inputData.length; i++) {
              const s = Math.max(-1, Math.min(1, inputData[i]));
              int16Data[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            
            deepgramSocket.send(int16Data.buffer);
          }
        };
        
        source.connect(processor);
        processor.connect(audioContext.destination);
      } catch (error) {
        console.error('Error setting up audio processing:', error);
        updateStatus('Errore configurazione audio: ' + error.message, 'error');
        stopRecording();
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      if (deepgramSocket) {
        if (deepgramSocket.readyState === WebSocket.OPEN) {
          deepgramSocket.close();
        }
        deepgramSocket = null;
      }

      if (processor) {
        processor.disconnect();
        processor = null;
      }

      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
        audioStream = null;
      }

      if (currentMode === 'realtime') {
        interimTranscript = '';
        updateTranscript();
      }

      startBtn.disabled = false;
      stopBtn.disabled = true;
      
      if (currentMode === 'realtime') {
        updateStatus('Modalit√† Tempo Reale - Pronto', 'idle');
      } else {
        updateStatus('Modalit√† Registra & Trascrivi - Pronto', 'idle');
      }
    }

    function clearTranscript() {
      finalTranscript = '';
      interimTranscript = '';
      updateTranscript();
    }

    startBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);
    clearBtn.addEventListener('click', clearTranscript);

    window.addEventListener('beforeunload', () => {
      stopRecording();
      if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
        relaySocket.close();
      }
    });
  </script>
</body>
</html>
